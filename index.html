<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WCA Progress Chart</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/luxon@3.4.4/build/global/luxon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.umd.min.js"></script>
    <style>
        /* Apply Inter font */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom styles for Chart.js tooltips */
        .chartjs-tooltip {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 4px;
            padding: 6px;
            font-size: 12px;
        }
        .chartjs-tooltip-key {
            display: inline-block;
            width: 10px;
            height: 10px;
            margin-right: 4px;
        }
        /* Ensure canvas is responsive */
        canvas {
             max-width: 100%; /* Prevent canvas from exceeding container width */
             height: auto !important; /* Maintain aspect ratio */
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 p-4 md:p-8 font-sans">

    <div class="max-w-6xl mx-auto bg-white p-6 rounded-lg shadow-md">
        <h1 class="text-2xl font-bold mb-6 text-center text-gray-800">WCA Progress Viewer</h1>

        <form id="wcaForm" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6 items-end">
            <div>
                <label for="wcaids" class="block text-sm font-medium text-gray-700 mb-1">WCA ID(s):</label>
                <input type="text" id="wcaids" name="wcaids" placeholder="e.g., 2023HELE02, 2022SUHC01" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 text-sm" required>
                 <p class="text-xs text-gray-500 mt-1">Enter one or more WCA IDs, separated by commas.</p>
           </div>
            <div>
                <label for="event" class="block text-sm font-medium text-gray-700 mb-1">Event:</label>
                <select name="event" id="event" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 text-sm bg-white">
                    <option value="333">3x3x3 Cube</option>
                    <option value="222">2x2x2 Cube</option>
                    <option value="444">4x4x4 Cube</option>
                    <option value="555">5x5x5 Cube</option>
                    <option value="666">6x6x6 Cube</option>
                    <option value="777">7x7x7 Cube</option>
                    <option value="333bf">3x3x3 Blindfolded</option>
                    <option value="333fm">3x3x3 Fewest Moves</option>
                    <option value="333oh">3x3x3 One-Handed</option>
                    <option value="clock">Clock</option>
                    <option value="minx">Megaminx</option>
                    <option value="pyram">Pyraminx</option>
                    <option value="skewb">Skewb</option>
                    <option value="sq1">Square-1</option>
                    <option value="444bf">4x4x4 Blindfolded</option>
                    <option value="555bf">5x5x5 Blindfolded</option>
                    <option value="333mbf">3x3x3 Multi-Blind</option>
                </select>
            </div>
            <div>
                <label for="type" class="block text-sm font-medium text-gray-700 mb-1">Result Type:</label>
                <select name="type" id="type" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 text-sm bg-white">
                    <option value="average">Average</option>
                    <option value="best">Single</option>
                </select>
            </div>
            <div class="lg:col-span-1 flex justify-center md:justify-start">
                <button type="submit" id="submitBtn" class="w-full md:w-auto inline-flex justify-center py-2 px-4 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                    Load Chart
                </button>
            </div>
        </form>

        <div id="messageArea" class="mb-4 text-center text-sm text-red-600 min-h-[20px]"></div>
         <div id="loadingIndicator" class="text-center text-gray-600 mb-4 hidden">
            <svg class="animate-spin h-5 w-5 text-indigo-600 inline-block mr-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            Loading data...
        </div>

        <div class="bg-gray-50 p-4 rounded-md shadow-inner">
             <div class="relative w-full h-auto aspect-video"> <canvas id="progressChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        // Global variable to hold the chart instance
        let progressChart = null;
        // Define some colors for the chart lines
        const chartColors = [
            'rgb(75, 192, 192)', 'rgb(255, 99, 132)', 'rgb(54, 162, 235)',
            'rgb(255, 205, 86)', 'rgb(153, 102, 255)', 'rgb(255, 159, 64)',
            'rgb(201, 203, 207)'
        ];

        // DOM Elements
        const form = document.getElementById('wcaForm');
        const wcaIdsInput = document.getElementById('wcaids');
        const eventSelect = document.getElementById('event');
        const typeSelect = document.getElementById('type');
        const submitBtn = document.getElementById('submitBtn');
        const messageArea = document.getElementById('messageArea');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const canvas = document.getElementById('progressChart');
        const ctx = canvas.getContext('2d');

        /**
         * Formats time in centiseconds into a string (MM:SS.ss or SS.ss).
         * Handles DNF (-1) and DNS (-2) values.
         * @param {number} centiseconds - Time in centiseconds, or -1 for DNF, -2 for DNS.
         * @returns {string} Formatted time string or 'DNF'/'DNS'.
         */
        function formatTime(centiseconds) {
            if (centiseconds <= 0) {
                // WCA API uses -1 for DNF, -2 for DNS. Sometimes 0 might appear.
                return centiseconds === -1 ? "DNF" : (centiseconds === -2 ? "DNS" : "N/A");
            }
            const totalSeconds = centiseconds / 100;
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = (totalSeconds % 60);

            if (minutes > 0) {
                return `${minutes}:${seconds.toFixed(2).padStart(5, '0')}`; // MM:SS.ss
            } else {
                return `${seconds.toFixed(2)}`; // SS.ss
            }
        }

         /**
         * Formats FMC (Fewest Moves Challenge) results.
         * @param {number} moves - Number of moves.
         * @returns {string} Formatted moves string or 'DNF'/'DNS'.
         */
        function formatFmc(moves) {
             if (moves <= 0) {
                return moves === -1 ? "DNF" : (moves === -2 ? "DNS" : "N/A");
            }
            return `${moves} moves`;
        }

        /**
         * Formats Multi-Blind results.
         * The result format is complex: DDTTTTTMM (DD = 99 - difference, TTTTT = time in seconds, MM = missed cubes)
         * Example: 910379802 -> 99-8 = 91 points, 3798s time, 2 missed
         * @param {number} value - The encoded MBLD result.
         * @returns {string} Formatted MBLD string (Points | Time | Missed) or 'DNF'/'DNS'.
         */
        function formatMbld(value) {
             if (value <= 0) {
                return value === -1 ? "DNF" : (value === -2 ? "DNS" : "N/A");
            }
            const s = value.toString().padStart(9, '0'); // Pad with leading zeros if necessary
            const difference = 99 - parseInt(s.substring(0, 2), 10);
            const timeInSeconds = parseInt(s.substring(2, 7), 10);
            const missed = parseInt(s.substring(7, 9), 10);
            const solved = difference + missed;
            const attempted = solved + missed;
            const points = solved - missed;

            // Format time MM:SS
            const minutes = Math.floor(timeInSeconds / 60);
            const seconds = timeInSeconds % 60;
            const formattedTime = `${minutes}:${seconds.toString().padStart(2, '0')}`;

            return `${points} pts (${solved}/${attempted} ${formattedTime})`;
         }


        /**
         * Fetches WCA data for a single WCA ID.
         * @param {string} wcaId - The WCA ID to fetch data for.
         * @returns {Promise<object|null>} A promise resolving to the data object or null if fetch fails.
         */
        async function fetchWcaData(wcaId) {
            // Using the robiningelbrecht pre-parsed data source
            // Note: This is not the official WCA API and might have delays or discrepancies.
            const apiUrl = `https://raw.githubusercontent.com/robiningelbrecht/wca-rest-api/master/api/persons/${wcaId.toUpperCase()}.json`;
            try {
                const response = await fetch(apiUrl);
                if (!response.ok) {
                    // Handle common errors like 404 Not Found
                    if (response.status === 404) {
                        throw new Error(`WCA ID ${wcaId} not found.`);
                    }
                    throw new Error(`Failed to fetch data for ${wcaId}. Status: ${response.status}`);
                }
                const data = await response.json();
                // Basic validation if data seems correct (e.g., has a 'results' property)
                if (!data || !data.results) {
                     throw new Error(`Invalid data format received for ${wcaId}.`);
                }
                return data;
            } catch (error) {
                console.error(`Error fetching WCA data for ${wcaId}:`, error);
                setMessage(`Error for ${wcaId}: ${error.message}`, 'error');
                return null; // Return null to indicate failure for this ID
            }
        }

        /**
         * Processes the fetched data for a specific event and type.
         * @param {object} data - The fetched WCA data for one person.
         * @param {string} eventId - The event ID (e.g., '333').
         * @param {string} resultType - 'average' or 'best'.
         * @returns {Array} An array of objects { x: competitionName, y: value }.
         */
        function processData(data, eventId, resultType) {
            const results = [];
            const competitions = data.results || {}; // Ensure 'results' exists

            // Sort competitions chronologically (assuming keys are competition IDs which might not be strictly chronological)
            // A better approach would be to use competition dates if available, but this data source doesn't seem to have them easily accessible per result.
            // We'll rely on the order in the JSON for now.
            const competitionIds = Object.keys(competitions);

            competitionIds.forEach(compId => {
                const compResults = competitions[compId];
                if (compResults[eventId]) {
                    compResults[eventId].forEach(roundResult => {
                        // WCA API uses -1 for DNF, -2 for DNS. 0 might also indicate no valid time.
                        const value = roundResult[resultType];
                        // We plot DNFs/DNS as null so Chart.js shows a gap in the line
                        const plotValue = (value !== undefined && value > 0) ? value : null;

                        // Handle special formatting cases
                        let formattedValue = null;
                        if (plotValue !== null) {
                             if (eventId === '333fm') {
                                // FMC is measured in moves (use 'best' only)
                                formattedValue = plotValue; // Keep raw value for plotting
                            } else if (eventId === '333mbf') {
                                // MBLD uses a special format (use 'best' only)
                                formattedValue = plotValue; // Keep raw value for plotting
                            } else {
                                // Other events are time-based (centiseconds)
                                formattedValue = plotValue / 100; // Convert centiseconds to seconds for plotting
                            }
                        }


                        results.push({
                            x: `${compId} ${roundResult.round}`, // Label for the data point
                            y: formattedValue, // Value to plot (null for DNFs/invalid)
                            rawValue: value // Store original value for tooltips
                        });
                    });
                }
            });

            // The data seems to be roughly chronological, but reversing might be needed
            // depending on the source data structure. Let's keep it as is for now.
            // If points appear backwards, uncomment the next line:
            // results.reverse();
            return results;
        }

        /**
         * Sets a message in the message area.
         * @param {string} text - The message text.
         * @param {'info'|'error'} type - The type of message.
         */
        function setMessage(text, type = 'info') {
            messageArea.textContent = text;
            messageArea.className = `mb-4 text-center text-sm min-h-[20px] ${type === 'error' ? 'text-red-600' : 'text-gray-600'}`;
        }

        /**
         * Loads and displays the chart based on form inputs.
         */
        async function loadChart() {
            const wcaIdString = wcaIdsInput.value.trim();
            const eventId = eventSelect.value;
            let resultType = typeSelect.value;

            setMessage(''); // Clear previous messages
            loadingIndicator.classList.remove('hidden'); // Show loading
            submitBtn.disabled = true; // Disable button during load

            if (!wcaIdString) {
                setMessage('Please enter at least one WCA ID.', 'error');
                loadingIndicator.classList.add('hidden');
                submitBtn.disabled = false;
                return;
            }

            // Handle special case for 333mbf (Multi-Blind) - only 'best' result makes sense
            if (eventId === '333mbf') {
                resultType = 'best';
                typeSelect.value = 'best'; // Update dropdown visually
                // Consider disabling the type dropdown for MBLD
            }
             // Handle special case for 333fm (Fewest Moves) - only 'best' result makes sense
            if (eventId === '333fm') {
                resultType = 'best';
                typeSelect.value = 'best'; // Update dropdown visually
                 // Consider disabling the type dropdown for FMC
           }


            const wcaIds = wcaIdString.split(',')
                .map(id => id.trim())
                .filter(id => id.length > 0); // Get individual, trimmed IDs

            if (wcaIds.length === 0) {
                 setMessage('Please enter valid WCA IDs.', 'error');
                 loadingIndicator.classList.add('hidden');
                 submitBtn.disabled = false;
                 return;
            }

            // Fetch data for all IDs concurrently
            const allDataPromises = wcaIds.map(id => fetchWcaData(id));
            const allDataResults = await Promise.all(allDataPromises);

            const datasets = [];
            let commonLabels = new Set(); // Use a Set to collect all unique competition/round labels

            allDataResults.forEach((data, index) => {
                if (data) { // Check if data fetching was successful for this ID
                    const wcaId = data.person.wca_id || wcaIds[index]; // Use ID from data if available
                    const processedResults = processData(data, eventId, resultType);

                    if (processedResults.length > 0) {
                        processedResults.forEach(point => commonLabels.add(point.x)); // Add labels to the set

                        datasets.push({
                            label: `${wcaId} ${eventId} ${resultType}`,
                            data: processedResults, // Use the processed data directly {x, y, rawValue}
                            borderColor: chartColors[index % chartColors.length],
                            backgroundColor: chartColors[index % chartColors.length] + '80', // Slightly transparent fill
                            tension: 0.1,
                            fill: false,
                            spanGaps: false, // Don't connect lines across null points (DNFs)
                            pointRadius: 3,
                            pointHoverRadius: 6,
                            borderWidth: 2
                        });
                    } else {
                         setMessage(`No results found for ${wcaId} for event ${eventId}.`, 'info');
                    }
                }
                // If data is null, an error message was already shown by fetchWcaData
            });

             // Convert the set of labels to a sorted array.
             // This ensures all datasets plot against the same chronological x-axis.
             // Sorting might be basic string sort; more robust date sorting would require date info.
             const sortedLabels = Array.from(commonLabels).sort();


            loadingIndicator.classList.add('hidden'); // Hide loading
            submitBtn.disabled = false; // Re-enable button

            if (datasets.length === 0) {
                 setMessage('No valid data found for the selected criteria.', 'error');
                 // Destroy previous chart if it exists
                 if (progressChart) {
                    progressChart.destroy();
                    progressChart = null;
                 }
                 return; // Don't draw if no data
            }


            // Destroy previous chart instance if it exists
            if (progressChart) {
                progressChart.destroy();
            }

            // Create the new chart
            progressChart = new Chart(ctx, {
                type: 'line',
                data: {
                    // labels: sortedLabels, // Use the sorted unique labels for the x-axis
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false, // Allow chart to fill container aspect ratio
                    parsing: {
                         // Tell Chart.js how to find the x and y values in our data objects
                        xAxisKey: 'x',
                        yAxisKey: 'y'
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Competition & Round'
                            },
                            ticks: {
                                // Auto-skip ticks to prevent overlap on small screens
                                autoSkip: true,
                                maxTicksLimit: 15 // Adjust as needed
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: `Result (${resultType === 'average' ? 'Average' : 'Single'})`
                            },
                            ticks: {
                                // Custom tick formatting based on event
                                callback: function(value, index, ticks) {
                                     if (eventId === '333fm') return formatFmc(value);
                                     if (eventId === '333mbf') return formatMbld(value); // MBLD raw value needs special formatting
                                     // For time-based events, value is already in seconds
                                     return formatTime(value * 100); // Convert back to centiseconds for formatting
                                }
                            },
                            beginAtZero: false // Don't force y-axis to start at 0 for time
                        }
                    },
                    plugins: {
                        tooltip: {
                            enabled: true,
                            mode: 'index', // Show tooltips for all datasets at the same index
                            intersect: false, // Show tooltip even if not directly hovering over point
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleFont: { size: 14 },
                            bodyFont: { size: 12 },
                            padding: 10,
                            callbacks: {
                                // Custom tooltip title (e.g., Competition Name)
                                title: function(tooltipItems) {
                                     return tooltipItems[0]?.label || ''; // Get label from the first item
                                },
                                // Custom tooltip body to show formatted time/result
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    const wcaIdLabel = label.split(' ')[0]; // Extract WCA ID part
                                    if (wcaIdLabel) {
                                        label = wcaIdLabel + ': ';
                                    } else {
                                        label = '';
                                    }

                                    const rawValue = context.raw.rawValue; // Get the original value
                                    if (rawValue !== null && rawValue !== undefined) {
                                         if (eventId === '333fm') {
                                            label += formatFmc(rawValue);
                                        } else if (eventId === '333mbf') {
                                            label += formatMbld(rawValue);
                                        } else {
                                            label += formatTime(rawValue); // Format the original centiseconds value
                                        }
                                    } else {
                                        label += 'N/A'; // Or DNF/DNS if rawValue indicates that
                                    }
                                    return label;
                                },
                                // Add color swatch to tooltip
                                labelColor: function(context) {
                                    return {
                                        borderColor: context.dataset.borderColor,
                                        backgroundColor: context.dataset.backgroundColor,
                                        borderWidth: 2,
                                        borderRadius: 2,
                                    };
                                },
                            }
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                usePointStyle: true, // Use point style (circle) in legend
                                padding: 20 // Add padding to legend items
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest', // Find nearest item in all datasets
                        axis: 'x',       // Only check along the x-axis
                        intersect: false
                    }
                }
            });
        }

        // Add event listener to the form
        form.addEventListener('submit', function(event) {
            event.preventDefault(); // Prevent default form submission
            loadChart();
        });

        // Optional: Load a default chart on page load
        // window.onload = () => {
        //     wcaIdsInput.value = '2022YAOC02'; // Example default ID
        //     loadChart();
        // };

    </script>

</body>
</html>
